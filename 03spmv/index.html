<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" / >
<title>SpMV hands-on instructions</title>


<style>
body {counter-reset: h2}
  h2 {counter-reset: h3}
  h3 {counter-reset: h4}
  h4 {counter-reset: h5}
  h5 {counter-reset: h6}

  h2:before {counter-increment: h2; content: counter(h2) ". "}
  h3:before {counter-increment: h3; content: counter(h2) "." counter(h3) ". "}
  h4:before {counter-increment: h4; content: counter(h2) "." counter(h3) "." counter(h4) ". "}
  h5:before {counter-increment: h5; content: counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". "}
  h6:before {counter-increment: h6; content: counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". "}

  h2.nocount:before, h3.nocount:before, h4.nocount:before, h5.nocount:before, h6.nocount:before { content: ""; counter-increment: none } 

h1 {
  font-size   : 14pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt ;
   
  border-color     : #99A1AA;
  background-color : #BBDDBB;
}

h2 {
  font-size   : 13pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 15pt ;
   
  border-color     : #99A1AA;
  background-color : #CCEECC;
}

h3 {
  font-size   : 12pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 1pt;
  border-color     : #99A1AA;
  background-color : #DDFFDD;
}

h4 {
  font-size   : 10pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-style     : solid;
  border-width     : 1pt 1pt 0pt 1pt;
  border-color     : #99A1AA;
  background-color : #FFFFFF;
}

div {
  font-size   : 12pt;
  font-family : serif;
  margin      : 10pt;
  padding     : 3pt 20pt;
  border-color     : #99A1AA;
}

p {
  font-size   : 12pt;
  font-family : serif;
  border-color     : #99A1AA;
}

pre {
  background-color:#efe;
}

</style>
</head>

<body>

<h1>SpMV hands-on instructions</h1>

<a name=fork> </a>
<h2>Fork the code to get your own repository</h2>
<div>
  <p><i><font color=red>Everybody needs to do this.</font>
      Instructions have been updated since the last week, so that I can
      track your code easily and you can easily transfer you code between your laptop
      and the remote machine.</i>
  </p>
  <p>
    <ol>
      <li>visit <a href="https://doss-gitlab.eidos.ic.i.u-tokyo.ac.jp/" target="_blank">
          our gitlab server</a> and register yourself <br />
        <a href="img/gitlab-register.png"><img width=400 src="img/gitlab-register.png" /></a>
      </li>
      <li>after you registered, sign in 
        <a href="https://doss-gitlab.eidos.ic.i.u-tokyo.ac.jp/" target="_blank">
          the gitlab server
        </a>
        and visit
        <a href="https://doss-gitlab.eidos.ic.i.u-tokyo.ac.jp/tau/parallel-distributed-handson" target="_blank">
          the hands-on project page. </a>
        <br />
        <a href="img/gitlab-hands-on.png"><img width=400 src="img/gitlab-hands-on.png" /></a>
      </li>
      <li>Fork the project by pressing the "Fork" button,
        to make your own copy of the project.
      </li>
      <li>After you successfully forked it, visit the repository you just created.
        Find it by cliking on "Project" -&gt; "Your project".
        The project page should be like "YOUR NAME/parallel-distributed-handson".
        Make sure it is NOT "Kenjiro Taura/parallel-distributed-handson".
      </li>
      <li>This repository is your working space.
        You are going to commit your work into this repository.
        If you clone this directory into the IST cluster (which you must in any case)
        and your laptop, you can easily transfer changes between them.
        You can work in your laptop a while, do a simple test and perform
        a measurement and/or a larger production run on the IST cluster.
      </li>
    </ol>
  </p>
</div>

<a name=clone> </a>
<h2>Clone your repository</h2>
<div>
  <p>
    <ol>
      <li>Clone the repository you just created.  At the minimum, you need to clone it
        in the IST cluster, to run your experiments.  Besides, you may want to clone it
        in your laptop or whichever environment you want to develop your code in.  Either case,
        copy the URL shown in your project page and do
<pre>
$ <u>git clone https://doss-gitlab.eidos.ic.i.u-tokyo.ac.jp/uratau/parallel-distributed-handson.git</u>
</pre>
      </li>
      <li><font color=orange>Alternatively</font> you can 
<pre>
$ <u>git clone git@doss-gitlab.eidos.ic.i.u-tokyo.ac.jp:uratau/parallel-distributed-handson.git</u>
</pre>
The latter method is more convenient down the road, but for it to work, you need to
first <a href=#gitlab-ssh>register your SSH key to our gitlab server.</a>
I'll defer how to do it later and go ahead for now
      </li>
    </ol>
  </p>
</div>

<a name=roadmap> </a>
<h2>The roadmap</h2>
<div>
  <p>
    You see the detailed instructions of hands-on excercise below
    from the basics of git and gdb to how to exactly send your work to me.
    You can follow them basically on a paragraph by paragraph basis,
    but if you think you already know the basics and want to jump into
    the specifics of the work you are supposed to do,
    search for "assignment".
  </p>
</div>

<a name=play-with-it> </a>
<h2>Play with it</h2>
<h3>Make it</h3>
<div>
  <p>If you clone the directory, you will find <tt>03spmv</tt> directory,
    the main working directory of the assignment. Build it by typing <tt>make</tt>
<pre>
$ <u>make</u>
g++ -o spmv.gcc spmv.cc  -Wall -Wextra -O3 -fopenmp  
/usr/local/cuda/bin/nvcc -o spmv.nvcc -x cu spmv.cc  --gpu-code sm_60 --gpu-architecture compute_60 -O3 -Xptxas -O3,-v  
</pre>
If successful, you will get two executable <tt>spmv.gcc</tt> (compiled by g++)
and <tt>spmv.nvcc</tt> (compiled by nvcc).  If you work in your environment (not IST cluste)
and do not have nvcc (NVIDIA compiler), remove <tt>spmv.nvcc</tt> from the target so that
it does not try to make spmv.nvcc. For that, open <tt>Makefile</tt> and commenting out the following
line
<pre>
 ... (in the Makefile) ...
exe += $(app).nvcc
</pre>
by putting <tt>#</tt> mark in front of the line.
<pre>
 ... (in the Makefile) ...
# exe += $(app).nvcc
</pre>
  </p>
</div>

<h3>Run it</h3>
<div>
  <ul>
    <li>On the IST cluster do
<pre>
$ <u>srun -p PARTITION -t 0:01:00 ./spmv.gcc</u>
A : 20000 x 10000, 2000000 requested non-zeros
repeat : 5 times
format : coo
matrix : rmat
algo : serial
spmv.cc:1927:main: generating matrix starts ... 
spmv.cc:1930:main: generating matrix ends 20000 x 10000 with 2000000 non-zeros
spmv.cc:1810:dump_sparse_file: dumping to matrix 20000 x 10000 (2000000 nnz) -> rmat.gnuplot
spmv.cc:1896:dump_sparse_file: done
spmv.cc:1701:repeat_spmv: warm up + error check starts
spmv.cc:1712:repeat_spmv: warm up + error check ends
spmv.cc:1715:repeat_spmv: starts
spmv.cc:1728:repeat_spmv: ends
40150000 flops in 4.971900600e-02 sec (8.075382682e-01 GFLOPS)
lambda = 4.673961458e+06
</pre>
where PARTITION is any partition of the IST cluster (knm, big, p or v) but since
this is not using GPU, I recommend big (Xeon multicore) or knm (Xeon Phi many core).
For other options of srun see <tt>00slurm</tt> directory.
    </li>
    <li>On your own machine, simply do
<pre>
$ <u>./spmv.gcc</u>
</pre>
You are allowed to do the same thing if you carefully choose parameters so that it finishes
quickly with a small number of cores.  Be sure to use srun when you use many cores or the
program takes a long time.
    </li>
  </ul>
</div>

<h3>Study the output</h3>
<div>
  <p>
    Let's study the output a little bit.
<pre>
$ <u>srun -p PARTITION -t 0:01:00 ./spmv.gcc</u>
A : <font color=blue>20000</font> x <font color=blue>10000</font>, <font color=blue>2000000</font> requested non-zeros       # (1)
repeat : <font color=blue>5</font> times                                     # (2)
format : <font color=blue>coo</font>                                         # (3)
matrix : <font color=blue>rmat</font>                                        # (4)
algo : <font color=blue>serial</font>                                        # (5)
spmv.cc:1927:main: generating matrix starts ...      # (6)
spmv.cc:1930:main: generating matrix ends 20000 x 10000 with 2000000 non-zeros # (7)
spmv.cc:1810:dump_sparse_file: dumping to matrix 20000 x 10000 (2000000 nnz) -> rmat.gnuplot
spmv.cc:1896:dump_sparse_file: done
spmv.cc:1701:repeat_spmv: warm up + error check starts
spmv.cc:1712:repeat_spmv: warm up + error check ends
spmv.cc:1715:repeat_spmv: starts
spmv.cc:1728:repeat_spmv: ends
<font color=blue>40150000</font> flops in <font color=blue>4.971900600e-02</font> sec (<font color=blue>8.075382682e-01</font> GFLOPS)  # (8)
lambda = <font color=blue>4.673961458e+06</font>                             # (9)
</pre>
<ul>
  <li> Line (1)
<pre>
A : <font color=blue>20000</font> x <font color=blue>10000</font>, <font color=blue>2000000</font> requested non-zeros
</pre>
says the matrix is 20000 <font color=blue>(M)</font> x 10000 <font color=blue>(N)</font>
matrix
and it will have approximately 2000000 <font color=blue>(nnz)</font> non-zeros
(depending on the matrix generation
method, it may not be able to have the exact number of requested non-zeros).
  </li>
  <li> Line (2)
<pre>
repeat : <font color=blue>5</font> times
</pre>
says it repeats 5 times.  To be precise, the pseudo code of what it does the following.
<pre>
repeat 5 times {
  y = A x;  
  x = tA y;
  x = x / |x|
}
</pre>
tA is the transpose of A.  Note that each one takes space.  If you have nnz elements in A,
A and tA together approximately take (2 * nnz * sizeof(real)) bytes.
  <li> Line (3)
<pre>
format : <font color=blue>coo</font>
</pre>
says the matrix A and tA are in coo (Coordinate List) format.  You can specify
it with <tt>--format</tt> or <tt>-F</tt> option.
  </li>
  <li> Line (4)
<pre>
matrix : <font color=blue>random</font>
</pre>
says the matrix is a random matrix (a uniformly random matrix,
whose non-zeros are distributed uniformly over the matrix, to be precise).
You can specify it with <tt>--matrix-type</tt> or <tt>-t</tt> option.
  </li>
  <li> Line (5)
<pre>
algo : <font color=blue>serial</font>
</pre>
says the algorithm is a serial algorithm.
Its function name is
<tt>spmv_coo_serial().</tt>  The code follows the same convention for
other cases.  For example, the function for csr format with cuda is
<tt>spmv_csr_cuda().</tt>  The code given to you has already them defined
but they immediately raise an error if called.  Completing
these functions is your main job of the hands-on.  
  </li>
  <li> 
Starting from the next line, you see the matrix is generated.
  </li>
  <li> Line (6-7)
    You see the matrix is generated and it ends up with having
    2000000 non-zeros, just as requested.
  </li>
  <li> Line (8)
<pre>
<font color=blue>40150000</font> flops in <font color=blue>4.971900600e-02</font> sec (<font color=blue>8.075382682e-01</font> GFLOPS)
</pre>
reports how much work is done and how long it took, along with
the performance in GFLOPS (10^9 floating point operations per second).

Given M, N, nnz and repeat, the number of flops is
<pre>
repeat 5 times {
  y = A x;       # 2 nnz
  x = tA y;      # 2 nnz
  x = x / |x|    # 3 N
}
</pre>
<blockquote>
flops = (4 * nnz + 3 * N) * repeat
</blockquote>
In thie example, it is
<blockquote>
flops = (4 * 2000000 + 3 * 10000) * 5 = 40150000
</blockquote>
  </li>
  <li> Line (9)
<pre>
lambda = <font color=blue>4.673961458e+06</font>
</pre>
shows the answer from the algorithm.
It is the last |x| in the algorithm above, which
is the largest eigenvalue of (tA A), or
the largest singular value of A.
  </li>
</ul>
    Just as a heads up, the performance you
    just witnessed (8.075382682e-01 GFLOPS in this particular run)
    is less than 1/500 of the machine's peak FLOPS I happened to run it on.
    How far you can go from this, both with CPU and GPU,
    is a main topic I hope you are excited to be engaged in.
  </p>
</div>


<h3>Useful options</h3>
<div>
  <p>
    Let's try options. <tt>-h</tt> will show you the help
<pre>
$ <u>./spmv.gcc -h</u>
./spmv.gcc -h
usage:

  ./spmv.gcc [options ...]

options:
  --help             show this help
  --M N              set the number of rows to N [100000]
  --N N              set the number of colums to N [0]
  -z,--nnz N         set the number of non-zero elements to N [0]
  -r,--repeat N      repeat N times [5]
  -f,--format F      set sparse matrix format to F (coo,coo_sorted,csr) [coo]
  -t,--matrix-type M set matrix type to T (random,rmat,one,file) [random]
  -a,--algo A        set algorithm to A (serial,parallel,cuda,task,udr) [serial]
  --coo-file F       read matrix from F [mat.txt]
  --rmat a,b,c,d     set rmat probability [5,0,1,2]
  -s,--seed S        set random seed to S (use it with -t random or -t rmat) [4567890123]
  --dump F           dump matrix to a gnuplot file []
  --dump-points N    dump up to N points to a gnuplot file (use it with --dump) [20000]
  --dump-seed S      set random number seed to S to choose N points (use it with --dump-points) [91807290723]
</pre>
You can smell the framework in which this code is written.
You can also get various useful options to ease your work later.

<ul>
  <li><tt><font color=blue>--M</font>, <font color=blue>--N</font></tt> and <tt><font color=blue>--z</font></tt> : change the size of the matrix.
    You should use small numbers when you find your code does not work at all (e.g.,
    segmentation fault) and try to find the minimum case in which it does not work.
    You should large numbers when you work with a large number of cores.</li>
  <li><tt><font color=blue>-r</font></tt> :  Make sure you repeat the same computation a sufficient number
    of times to conduct a performance measurement.  It is often the case
    the computer behaves somewhat differently in the first iteration
    (due to paging, caches, etc.).  To be confident about what you are actually
    measuring, it is almost always a good idea to repeat it with a different number
    of times and the performance you get is consistent (remember: in some cases
    it is important to measure the performance of the first iteration.  I am not
    telling you to exclude inconvenient numbers from your experiments.  I am just
    saying make sure you are not confused by measuring what you do not intend to measure)
  </li>
  <li><tt><font color=blue>-f</font>, <font color=blue>-t</font> and <font color=blue>-a</font></tt> :
    set the format of the matrix, type of the matrix
    (how the matrix is generated) and the algorithm used (serial, parallel, cuda, etc.).
    Available options are shown in the help.  However, some options are not
    implemented and left for your exercise.
    Your main job in this hands-on is to implement all of them (except a few cases
    that do not make much sense).  If, for example, you choose <tt>-a parallel</tt> now,
    you get this.
<pre>
$ <u>./spmv.gcc -a parallel</u>
./spmv.gcc -a parallel
A : 100000 x 100000, 100000000 requested non-zeros
repeat : 5 times
format : coo
matrix : random
algo : parallel
spmv.cc:1968:main: generating matrix starts ... 
spmv.cc:1971:main: generating matrix ends 100000 x 100000 with 100000000 non-zeros
spmv.cc:1697:repeat_spmv: warm up + error check starts
*************************************************************
work/spmv_coo_parallel.cc:20:spmv_coo_parallel:
write a code that performs SPMV for COO format in parallel
using parallel for + atomic directives
*************************************************************
</pre>
You can locate your code by looking at the error message
(<tt>work/spmv_coo_parallel.cc:20</tt>).  Open it with an editor and work on it.
  </li>
  <li>Some matrix types (arguments to <tt><font color=blue>-t</font></tt>) will accept other options.
    <ul>
      <li><tt><font color=blue>-t file</font></tt> will read a matrix from a file, whose file name
        is specified with <tt><font color=blue>--coo-file</font></tt> option.  For example,
<pre>
$ <u>./spmv.gcc -t file --coo-file hoge.mat</u>
</pre>
will read a matrix from <tt>hoge.mat</tt>
      </li>
      <li><tt><font color=blue>-t rmap</font></tt> will generate a random matrix according to the
        <a href="https://epubs.siam.org/doi/abs/10.1137/1.9781611972740.43" target="_blank">
          R-MAT</a> model.  It takes four parameters that determines
        how non-zeros are distributed and the program can take
        them via <tt><font color=blue>--rmat</font></tt> option.
<pre>
$ <u>./spmv.gcc -t rmat --rmat 5,0,1,2</u>
</pre>
5, 0, 1 and 2 determine the relative probability with which
a non-zero element is in the upper-left, upper-right, lower-left and lower-right
part of the matrix, respectively.  For example, an element appears in
the upper-left part of the matrix with probability 5/(5+0+1+2) = 0.625.
This happens recursively in the chosen submatrix.
      </li>
      <li><tt><font color=blue>-s</font></tt> option specifies the seed of the random number generator
        used by matrix type <tt>rmat</tt> and <tt>random</tt>.
        The matrix is identical when you give the same seed
        and therefore the result should be identical (subject to
        rounding errors).
      </li>
    </ul>
  </li>
    
  <li><tt><font color=blue>--dump</font></tt> option dumps the matrix A you got for your
    visualization.  It generates a gnuplot file you can view by gnuplot.
<pre>
$ <u>./spmv.gcc --dump a.gnuplot</u>
     ...
spmv.cc:1810:dump_sparse_file: dumping to matrix 20000 x 10000 (2000000 nnz) -> a.gnuplot
spmv.cc:1896:dump_sparse_file: done
     ...
</pre>
If you did this on IST cluster, you may want to bring it to your laptop (by scp command).
<pre>
$ <u>gnuplot a.gnuplot</u>
</pre>
If you run this on your laptop, a window will pop up and you will see something like this.
<br />
<a href="img/nnz_mat.png"> <img width=300 src="img/nnz_mat.png" /> </a>
<br />
This shows the distribution of non-zero elements over the matrix.
Note that the horizontal axis is the rows and vertical axis the columns,
not a usual way to display a matrix (please tell me if you know how to easily fix this).
To avoid overwhelming gnuplot with too much data, up to 20000 elements
are randomly sampled.  The number can be configured with <tt>--dump-points</tt>
option.
<br />
Go back to your terminal and press Enter, which pops up the next graph.
<br />
<a href="img/nnz_row.png"> <img width=300 src="img/nnz_row.png" /></a>
<br />
This shows the distribution of non-zero elements over rows,
giving you an idea about the load balancing if you divide rows into cores.
<br />
Both graphs are not surprising (and are somewhat boring) as their
non-zero elements are uniformly distributed.  The non-zeros are evenly
distributed over rows and over the 2D space.
  </li>
</ul>
  </p>    
</div>

  

<a name=structure> </a>
<h2>How the code is structured</h2>
<div>
  <p>

  </p>
</div>

<a name=gitlab-ssh> </a>
<h2>Register your SSH key to the gitlab server</h2>
<div>
</div>



</body>
</html>

